* Note:  Trying to figure out where gaps really are in gcc/arch output.
  The "helpful" printf statement changes the allocation. Probably because of the
  temp variable.  Try using a global.
  */

The program array_underflow_*.c allows users to edit employee information.
However, the edit_employees function needs to be passed non-zero values 
for can_edit_record and can_edit_salary in order for the user to be allowed
to edit salaries. Let's see if we can get around that restriction and change
salaries anyway.

Notice that this program avoids scanf, and uses strncpy so as to avoid string
buffer overflows.


1. Draw a diagram of the stack contents when the program reaches the switch 
   statement for the first time.

2. Even though string buffer overflows aren't possible, it is still possible
   to change an employee's salary.  Can you figure out how? 
   * Hint: Look at the stack trace and carefully choose an "employee" to modify.

3. Notice that this code uses my_strncpy to copy strings.
   a. How does my_strncppy differ from the clib's strncpy?
   b. How does this difference affect the outcome of your attack?

4. If your compiler includes stack protection, modify an "employee" in a way 
   that trips this alarm and causes the program to be terminated.

Answers:

1. See below

2. Edit employee "-1". Editing this employee will modify the local variables in 
   edit_employees.

3a. clib's strncpy will fill the remaining bytes in the target array with 0s.
3b. This thwarts our attack because the extra 0s end up overwriting the function's 
    return address and/or stack check, resulting in a seg fault.

=====

Answer to #1 when compiled using clang on an x86 mac.
Notice that the placement of parameters on the stack  is not in the order they appear in the code.
The idea of the "dummy" data was to help students see what parts of the stack were modified.  However,
since the parameters weren't placed in order, these "guideposts" may not be as useful as I had hoped.


stack    addr as shown
         in assembly 
   0                         rsp when entering main 
  -8                         rbp pushed to begin main / rbp for main
 -16     main -8(rbp)        stack check for main 
                             employees[2]
                             employees[1]
                             employees[0]
-232     main -224(rbp)      Beginning of employee array
         main -228(rbp)      0
         main -232(rbp)      argc   
-248     main -240(rbp)      argv / rsp after setting up main
-256                         return address for edit_employees function ("edit")
-264                         rbp pushed to begin edit_employees / rbp for "edit"
-272       edit -8(rbp)      stack check for "edit"
-280      edit -16(rbp)      message1 
-288      edit -24(rbp)      message2
-296      edit -32(rbp)      Employee* variable
-300      edit -36(rbp)      choice variable
-304      edit -40(rbp)      emp_num variable 
-320      edit -56(rbp)      Employee array pointer parameter
-324      edit -60(rbp)      can_edit_salary parameter
-328      edit -64(rbp)      rsp after setting up edit_employees  

=====

Answer to #1 when compiled using gcc on an x86 running Linux
Notice that the placement of parameters on the stack  is not in the order they appear in the code.


stack    addr as shown
         in assembly 
   0                         rsp when entering main 
  -8                         rbp pushed to begin main / rbp for main
 -16     main -8(rbp)        stack check for main 
                             employees[2]
                             employees[1]
                             employees[0]
-232     main -224(rbp)      Beginning of employee array
         main -228(rbp)      argc
         main -232(rbb)      <appears to be unused>   
-248     main -240(rbp)      argv / rsp after setting up main
-256                         return address for edit_employees function (aka "edit")
-264			     <some 8 bytes between argv and emp appears unused.>
-272                         rbp pushed to begin edit_employees / rbp for "edit"
-280      edit  -8(rbp)      emp (local variable)
-284      edit -12(rbp)      choice (local variable)
-288      edit -16(rbp)      both_permissions (local variable)
-292      edit -20(rbp)      emp_num (local variable)
-304	  edit -32(rbp)      <apparantly unused>
-308	  edit -36(rbp)      can_edit_record parameter
-312      edit -40(rbp)      can_edit_salary parameter
-320      edit -48(rbp)      Employee* employees / rsp after setting up edit_employees  
