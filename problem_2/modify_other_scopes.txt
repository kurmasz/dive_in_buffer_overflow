The program array_underflow_*.c allows users to edit employee information.
However, the edit_employees function needs to be passed non-zero values 
for can_edit_record and can_edit_salary in order for the user to be allowed
to edit salaries. Let's see if we can get around that restriction and change
salaries anyway.

Notice that this program avoids scanf, and uses strncpy so as to avoid string
buffer overflows.


1. Draw a diagram of the stack contents when the program reaches the switch 
   statement for the first time.

2. Even though string buffer overflows aren't possible, it is still possible
   to change an employee's salary.  Can you figure out how? 
   * Hint: Look at the stack trace and carefully choose an "employee" to modify.

3. Notice that this code uses my_strncpy to copy strings.
   a. How does my_strncppy differ from the clib's strncpy?
   b. How does this difference affect the outcome of your attack?

4. If your compiler includes stack protection, modify an "employee" in a way 
   that trips this alarm and causes the program to be terminated.

Answers:

1. See below

2. Edit employee "-1". Editing this employee will modify the local variables in 
   edit_employees.
   * On x86/gcc edit the name and change character 21.
   * On x86/gcc with the "hint" printfs uncommented, edit the name and change character 8.

3a. clib's strncpy will fill the remaining bytes in the target array with 0s.
3b. This thwarts our attack because the extra 0s end up overwriting the function's 
    return address and/or stack check, resulting in a seg fault.

=====

Answer to #1 when compiled using clang on an x86 mac.
Notice that the placement of parameters on the stack  is not in the order they appear in the code.
The idea of the "dummy" data was to help students see what parts of the stack were modified.  However,
since the parameters weren't placed in order, these "guideposts" may not be as useful as I had hoped.


stack    addr as shown
         in assembly 
   0                         rsp when entering main 
  -8                         rbp pushed to begin main / rbp for main
 -16     main -8(rbp)        stack check for main 
                             employees[2]
                             employees[1]
                             employees[0]
-232     main -224(rbp)      Beginning of employee array
         main -228(rbp)      0
         main -232(rbp)      argc   
-248     main -240(rbp)      argv / rsp after setting up main
-256                         return address for edit_employees function ("edit")
-264                         rbp pushed to begin edit_employees / rbp for "edit"
-272       edit -8(rbp)      stack check for "edit"
-280      edit -16(rbp)      message1 
-288      edit -24(rbp)      message2
-296      edit -32(rbp)      Employee* variable
-300      edit -36(rbp)      choice variable
-304      edit -40(rbp)      emp_num variable 
-320      edit -56(rbp)      Employee array pointer parameter
-324      edit -60(rbp)      can_edit_salary parameter
-328      edit -64(rbp)      rsp after setting up edit_employees  

=====

Answer to #1 when compiled using gcc on an x86 running Linux **with the extra printf commented out**.
Assembly generated using gcc -Wall -O0 -g -S array_underflow_gcc.c with gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04) 

Notice that the placement of parameters on the stack  is not in the order they appear in the code.
The compiler puts an unknown amount of padding on the stack between main and edit_employees. I tried to 
determine this padding by adding some extra printfs; but, the presence of the printfs changed the padding.
In addition, uncommenting the "helper" printfs on lines 96 and 97 causes the compiler to add a canary
to edit_employees.  (It's not there if those two lines are commented out.)


stack    addr as shown
         in assembly 
   0                         rsp when entering main 
  -8                         rbp pushed to begin main / rbp for main
 -16     main  -8(rbp)       stack check for main 
         main -24(rbp)       <appears to be unused>
                             employees[2]
                             employees[1]
                             employees[0]
-232     main -224(rbp)      Beginning of employee array
         main -228(rbp)      argc
         main -232(rbb)      <appears to be unused>   
-248     main -240(rbp)      argv / rsp after setting up main
                             return address for edit_employees function (aka "edit")
    			                 <some 8 bytes between argv and emp appears unused.>
                             rbp pushed to begin edit_employees / rbp for "edit"
          edit  -8(rbp)      emp (local variable)
          edit -12(rbp)      choice (local variable)
          edit -16(rbp)      both_permissions (local variable)
          edit -20(rbp)      emp_num (local variable)
    	    edit -32(rbp)      <apparently unused>
    	    edit -36(rbp)      can_edit_record parameter
          edit -40(rbp)      can_edit_salary parameter
          edit -48(rbp)      Employee* employees / rsp after setting up edit_employees  
